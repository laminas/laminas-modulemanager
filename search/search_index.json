{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"laminas-modulemanager Laminas\\ModuleManager introduces a new and powerful approach to modules. This new module system is designed with flexibility, simplicity, and re-usability in mind. A module may contain just about anything: PHP code, including MVC functionality; library code; view scripts; and/or public assets such as images, CSS, and JavaScript. The possibilities are endless. Laminas\\ModuleManager is the component that enables the design of a module architecture for PHP applications. Installation Run the following to install this library: $ composer require laminas/laminas-modulemanager Documentation Browse the documentation online at https://docs.laminas.dev/laminas-modulemanager/ Support Issues Chat Forum","title":"Home"},{"location":"#laminas-modulemanager","text":"Laminas\\ModuleManager introduces a new and powerful approach to modules. This new module system is designed with flexibility, simplicity, and re-usability in mind. A module may contain just about anything: PHP code, including MVC functionality; library code; view scripts; and/or public assets such as images, CSS, and JavaScript. The possibilities are endless. Laminas\\ModuleManager is the component that enables the design of a module architecture for PHP applications.","title":"laminas-modulemanager"},{"location":"#installation","text":"Run the following to install this library: $ composer require laminas/laminas-modulemanager","title":"Installation"},{"location":"#documentation","text":"Browse the documentation online at https://docs.laminas.dev/laminas-modulemanager/","title":"Documentation"},{"location":"#support","text":"Issues Chat Forum","title":"Support"},{"location":"best-practices/","text":"Best Practices when Creating Modules When creating a Laminas module, there are some best practices you should keep in mind. Keep the init() and onBootstrap() methods lightweight Be conservative with the actions you perform in the init() and onBootstrap() methods of your Module class. These methods are run for every page request, and should not perform anything heavy. As a rule of thumb, registering event listeners is an appropriate task to perform in these methods. Such lightweight tasks will generally not have a measurable impact on the performance of your application, even with many modules enabled. It is considered bad practice to utilize these methods for setting up or configuring instances of application resources such as a database connection, application logger, or mailer. Tasks such as these are better served through the ServiceManager capabilities. Do not perform writes within a module You should never code your module to perform or expect any writes within the module's directory. Once installed, the files within a module's directory should always match the distribution verbatim. Any user-provided configuration should be performed via overrides in the Application module or via application-level configuration files. Any other required filesystem writes should be performed in some writeable path that is outside of the module's directory. There are two primary advantages to following this rule. First, any modules which attempt to write within themselves will not be compatible with phar packaging. Second, by keeping the module in sync with the upstream distribution, updates via mechanisms such as git will be simple and trouble-free. Of course, the Application module is a special exception to this rule, as there is typically no upstream distribution for this module, and it's unlikely you would want to run this package from within a phar archive. Utilize a vendor prefix for module names To avoid module naming conflicts, you are encouraged to prefix your module namespace with a vendor prefix. As an example, the developer tools module distributed by Laminas is named \"Laminas\\DeveloperTools\" instead of simply \"DeveloperTools\". Utilize a module prefix for service names If you define services in the top-level service manager, you are encouraged to prefix these services with the name of your module to avoid conflicts with other modules' services. For example, the database adapter used by MyModule should be called \"MyModuleDbAdapter\" rather than simply \"DbAdapter.\" If you need to share a service with other modules, remember that the Service Manager \"alias\" feature can be used in a merged configuration to override factories defined by individual modules. Ideally, modules should define their own service dependencies, but aliases can be configured at the application level to ensure that common services in individual modules all refer to the same instance.","title":"Best Practices when Creating Modules"},{"location":"best-practices/#best-practices-when-creating-modules","text":"When creating a Laminas module, there are some best practices you should keep in mind.","title":"Best Practices when Creating Modules"},{"location":"best-practices/#keep-the-init-and-onbootstrap-methods-lightweight","text":"Be conservative with the actions you perform in the init() and onBootstrap() methods of your Module class. These methods are run for every page request, and should not perform anything heavy. As a rule of thumb, registering event listeners is an appropriate task to perform in these methods. Such lightweight tasks will generally not have a measurable impact on the performance of your application, even with many modules enabled. It is considered bad practice to utilize these methods for setting up or configuring instances of application resources such as a database connection, application logger, or mailer. Tasks such as these are better served through the ServiceManager capabilities.","title":"Keep the init() and onBootstrap() methods lightweight"},{"location":"best-practices/#do-not-perform-writes-within-a-module","text":"You should never code your module to perform or expect any writes within the module's directory. Once installed, the files within a module's directory should always match the distribution verbatim. Any user-provided configuration should be performed via overrides in the Application module or via application-level configuration files. Any other required filesystem writes should be performed in some writeable path that is outside of the module's directory. There are two primary advantages to following this rule. First, any modules which attempt to write within themselves will not be compatible with phar packaging. Second, by keeping the module in sync with the upstream distribution, updates via mechanisms such as git will be simple and trouble-free. Of course, the Application module is a special exception to this rule, as there is typically no upstream distribution for this module, and it's unlikely you would want to run this package from within a phar archive.","title":"Do not perform writes within a module"},{"location":"best-practices/#utilize-a-vendor-prefix-for-module-names","text":"To avoid module naming conflicts, you are encouraged to prefix your module namespace with a vendor prefix. As an example, the developer tools module distributed by Laminas is named \"Laminas\\DeveloperTools\" instead of simply \"DeveloperTools\".","title":"Utilize a vendor prefix for module names"},{"location":"best-practices/#utilize-a-module-prefix-for-service-names","text":"If you define services in the top-level service manager, you are encouraged to prefix these services with the name of your module to avoid conflicts with other modules' services. For example, the database adapter used by MyModule should be called \"MyModuleDbAdapter\" rather than simply \"DbAdapter.\" If you need to share a service with other modules, remember that the Service Manager \"alias\" feature can be used in a merged configuration to override factories defined by individual modules. Ideally, modules should define their own service dependencies, but aliases can be configured at the application level to ensure that common services in individual modules all refer to the same instance.","title":"Utilize a module prefix for service names"},{"location":"intro/","text":"Introduction to the Module System Laminas.0 introduced a new and powerful approach to modules. This new module system is designed with flexibility, simplicity, and re-usability in mind. A module may contain just about anything: PHP code, including MVC functionality; library code; view scripts; and/or public assets such as images, CSS, and JavaScript. The possibilities are endless. Event-based system The module system in Laminas has been designed to be a generic and powerful foundation from which developers and other projects can build their own module or plugin systems. For a better understanding of the event-driven concepts behind the Laminas module system, it may be helpful to read the EventManager documentation . The module system is made up of the following: The Module Autoloader - Laminas\\Loader\\ModuleAutoloader is a specialized autoloader that is responsible for the locating and loading of modules' Module classes from a variety of sources. The Module Manager - Laminas\\ModuleManager\\ModuleManager takes an array of module names and fires a sequence of events for each one, allowing the behavior of the module system to be defined entirely by the listeners which are attached to the module manager. ModuleManager Listeners - Event listeners can be attached to the module manager's various events. These listeners can do everything from resolving and loading modules to performing complex initialization tasks and introspection into each returned module object. Modules are PHP namespaces The name of a module in a Laminas application is a PHP namespace , and must follow all of the same rules for naming. The recommended structure for an MVC-oriented Laminas module is as follows: module_root/ Module.php autoload_classmap.php autoload_function.php autoload_register.php config/ module.config.php public/ images/ css/ js/ src/ &lt;module_namespace&gt;/ &lt;code files&gt; test/ phpunit.xml bootstrap.php &lt;module_namespace&gt;/ &lt;test code files&gt; view/ &lt;dir-named-after-module-namespace&gt;/ &lt;dir-named-after-a-controller&gt;/ &lt;.phtml files&gt; The autoload_*.php Files The three autoload_*.php files are not required, but recommended. They provide the following: autoload_classmap.php should return an array classmap of class name/filename pairs (with the filenames resolved via the __DIR__ magic constant). autoload_function.php should return a PHP callback that can be passed to spl_autoload_register() . Typically, this callback should utilize the map returned by autoload_classmap.php . autoload_register.php should register a PHP callback (typically that returned by autoload_function.php with spl_autoload_register() . The purpose of these three files is to provide reasonable default mechanisms for autoloading the classes contained in the module, thus providing a trivial way to consume the module without requiring laminas-modulemanager` (e.g., for use outside a Laminas application).","title":"Introduction"},{"location":"intro/#introduction-to-the-module-system","text":"Laminas.0 introduced a new and powerful approach to modules. This new module system is designed with flexibility, simplicity, and re-usability in mind. A module may contain just about anything: PHP code, including MVC functionality; library code; view scripts; and/or public assets such as images, CSS, and JavaScript. The possibilities are endless.","title":"Introduction to the Module System"},{"location":"intro/#the-autoload_php-files","text":"The three autoload_*.php files are not required, but recommended. They provide the following: autoload_classmap.php should return an array classmap of class name/filename pairs (with the filenames resolved via the __DIR__ magic constant). autoload_function.php should return a PHP callback that can be passed to spl_autoload_register() . Typically, this callback should utilize the map returned by autoload_classmap.php . autoload_register.php should register a PHP callback (typically that returned by autoload_function.php with spl_autoload_register() . The purpose of these three files is to provide reasonable default mechanisms for autoloading the classes contained in the module, thus providing a trivial way to consume the module without requiring laminas-modulemanager` (e.g., for use outside a Laminas application).","title":"The autoload_*.php Files"},{"location":"module-autoloader/","text":"The Module Autoloader laminas-modulemanager ships with the default module autoloader Laminas\\Loader\\ModuleAutoloader . It is a specialized autoloader responsible for locating and on-demand loading of, the Module classes from a variety of sources. Module Autoloader Usage By default, the provided Laminas\\ModuleManager\\Listener\\DefaultListenerAggregate sets up the ModuleAutoloader ; as a developer, you need only provide an array of module paths, either absolute or relative to the application's root, for the ModuleAutoloader to check when loading modules. The DefaultListenerAggregate will take care of instantiating and registering the ModuleAutoloader for you. Must be in application root In order for paths relative to your application directory to work, you must have the directive chdir(dirname(__DIR__)); in your public/index.php file. Registering module paths with the DefaultListenerAggregate The following example will search for modules in three different module_paths . Two are local directories of this application and the third is a system-wide shared directory. // public/index.php use Laminas\\ModuleManager\\Listener; use Laminas\\ModuleManager\\ModuleManager; chdir(dirname(__DIR__)); // Instantiate and configure the default listener aggregate $listenerOptions = new Listener\\ListenerOptions([ 'module_paths' =&gt; [ './module', './vendor', '/usr/share/laminasmodules', ] ]); $defaultListeners = new Listener\\DefaultListenerAggregate($listenerOptions); // Instantiate the module manager $moduleManager = new ModuleManager([ 'Application', 'FooModule', 'BarModule', ]); // Attach the default listener aggregate and load the modules $moduleManager-&gt;getEventManager()-&gt;attachAggregate($defaultListeners); $moduleManager-&gt;loadModules(); Module paths are FIFO Module paths behave very similar to PHP's include_path and are searched in the order they are defined. If you have modules with the same name in more than one registered module path, the module autoloader will return the first one it finds. Disabling the ModuleAutoloader Since 2.8.0 If you are using Composer to autoload, you may not need to use the ModuleAutoloader . As such, you can disable it by passing the following option to the ListenerOptions class: 'use_laminas_loader' =&gt; false, If your project was begun from the laminas-mvc-skeleton , place the above within the module_listener_options configuration of your config/application.config.php file: return [ /* ... */ 'module_listener_options' =&gt; [ 'use_laminas_loader' =&gt; false, /* ... */ ], /* ... */ ]; Non-Standard / Explicit Module Paths Sometimes you may want to specify exactly where a module is instead of having Laminas\\Loader\\ModuleAutoloader try to find it in the registered paths. Registering a Non-Standard / Explicit Module Path In this example, the autoloader will first check for MyModule\\Module in /path/to/mymoduledir-v1.2/Module.php . If it's not found, then it will fall back to searching any other registered module paths. // ./public/index.php use Laminas\\Loader\\ModuleAutoloader; use Laminas\\ModuleManager\\Listener; use Laminas\\ModuleManager\\ModuleManager; chdir(dirname(__DIR__)); // Instantiate and configure the default listener aggregate $listenerOptions = new Listener\\ListenerOptions([ 'module_paths' =&gt; [ './module', './vendor', '/usr/share/laminasmodules', 'MyModule' =&gt; '/path/to/mymoduledir-v1.2', ] ]); $defaultListeners = new Listener\\DefaultListenerAggregate($listenerOptions); /** * Without DefaultListenerAggregate: * * $moduleAutoloader = new ModuleAutoloader([ * './module', * './vendor', * '/usr/share/laminasmodules', * 'MyModule' =&gt; '/path/to/mymoduledir-v1.2', * ]); * $moduleAutoloader-&gt;register(); * */ // Instantiate the module manager $moduleManager = new ModuleManager([ 'MyModule', 'FooModule', 'BarModule', ]); // Attach the default listener aggregate and load the modules $moduleManager-&gt;getEventManager()-&gt;attachAggregate($defaultListeners); $moduleManager-&gt;loadModules(); This same method works if you provide the path to a phar archive. Packaging Modules with Phar If you prefer, you may easily package your module as a phar archive . The module autoloader is able to autoload modules in the following archive formats: .phar, .phar.gz, .phar.bz2, .phar.tar, .phar.tar.gz, .phar.tar.bz2, .phar.zip, .tar, .tar.gz, .tar.bz2, and .zip. Package your module by performing a tar the module directory. You can then replace the MyModule/ directory with MyModule.tar , and it should still be autoloaded without any additional changes! Avoid compression If possible, avoid using any type of compression (bz2, gz, zip) on your phar archives, as it introduces unnecessary CPU overhead to each request.","title":"The Module Autoloader"},{"location":"module-autoloader/#the-module-autoloader","text":"laminas-modulemanager ships with the default module autoloader Laminas\\Loader\\ModuleAutoloader . It is a specialized autoloader responsible for locating and on-demand loading of, the Module classes from a variety of sources.","title":"The Module Autoloader"},{"location":"module-autoloader/#module-autoloader-usage","text":"By default, the provided Laminas\\ModuleManager\\Listener\\DefaultListenerAggregate sets up the ModuleAutoloader ; as a developer, you need only provide an array of module paths, either absolute or relative to the application's root, for the ModuleAutoloader to check when loading modules. The DefaultListenerAggregate will take care of instantiating and registering the ModuleAutoloader for you.","title":"Module Autoloader Usage"},{"location":"module-autoloader/#non-standard-explicit-module-paths","text":"Sometimes you may want to specify exactly where a module is instead of having Laminas\\Loader\\ModuleAutoloader try to find it in the registered paths.","title":"Non-Standard / Explicit Module Paths"},{"location":"module-autoloader/#packaging-modules-with-phar","text":"If you prefer, you may easily package your module as a phar archive . The module autoloader is able to autoload modules in the following archive formats: .phar, .phar.gz, .phar.bz2, .phar.tar, .phar.tar.gz, .phar.tar.bz2, .phar.zip, .tar, .tar.gz, .tar.bz2, and .zip. Package your module by performing a tar the module directory. You can then replace the MyModule/ directory with MyModule.tar , and it should still be autoloaded without any additional changes!","title":"Packaging Modules with Phar"},{"location":"module-class/","text":"The Module Class By default, the module system expects each module name to be capable of resolving to an object instance. The default module resolver, Laminas\\ModuleManager\\Listener\\ModuleResolverListener , instantiates an instance of {moduleName}\\Module for each enabled module. A Minimal Module As an example, provided the module name \"MyModule\", Laminas\\ModuleManager\\Listener\\ModuleResolverListener will expect the class MyModule\\Module to be available. It relies on a registered autoloader (typically Laminas\\Loader\\ModuleAutoloader ) to find and include the MyModule\\Module class if it isn't already available. Module classes Since 2.8.0 Module classes can now be named anything, so long as they are autoloadable, and you use the fully qualified class name when registering it with the ModuleManager . The directory structure of a module named \"MyModule\" might start out looking something like this: MyModule/ Module.php Within Module.php , you define your MyModule\\Module class: namespace MyModule; class Module { } Though it will not serve any purpose at this point, this \"MyModule\" module now has everything required to be considered a valid module and to be loaded by the module system! This Module class serves as the single entry point for ModuleManager listeners to interact with a module. From within this class, modules can override or provide additional application configuration, perform initialization tasks such as registering autoloader(s), services and event listeners, declaring dependencies, and much more. A Typical Module Class The following example shows a more typical usage of the Module class: namespace MyModule; class Module { public function getAutoloaderConfig() { return [ 'Laminas\\Loader\\ClassMapAutoloader' =&gt; [ __DIR__ . '/autoload_classmap.php', ], 'Laminas\\Loader\\StandardAutoloader' =&gt; [ 'namespaces' =&gt; [ __NAMESPACE__ =&gt; __DIR__ . '/src/' . __NAMESPACE__, ], ], ]; } public function getConfig() { return include __DIR__ . '/config/module.config.php'; } } For a list of the provided module manager listeners and the interfaces and methods that Module classes may implement in order to interact with the module manager and application, see the module manager listeners and the module mananger events documentation. The loadModules.post Event It is not safe for a module to assume that any other modules have already been loaded at the time init() method is called. If your module needs to perform any actions after all other modules have been loaded, use the module manager's loadModules.post . Event information For more information on methods like init() and getConfig() , refer to the module manager listeners documentation . Sample Usage of \"loadModules.post\" Event use Laminas\\EventManager\\EventInterface as Event; use Laminas\\ModuleManager\\ModuleManager; class Module { public function init(ModuleManager $moduleManager) { // Remember to keep the init() method as lightweight as possible $events = $moduleManager-&gt;getEventManager(); $events-&gt;attach('loadModules.post', [$this, 'modulesLoaded']); } public function modulesLoaded(Event $e) { // This method is called once all modules are loaded. $moduleManager = $e-&gt;getTarget(); $loadedModules = $moduleManager-&gt;getLoadedModules(); // To get the configuration from another module named 'FooModule' $config = $moduleManager-&gt;getModule('FooModule')-&gt;getConfig(); } } Use init() sparingly The init() method is called for every module implementing this feature, on every page request, and should only be used for performing lightweight tasks such as registering event listeners. The MVC \"bootstrap\" Event If you are writing an MVC-oriented module, you may need access to additional parts of the application in your Module class such as the instance of Laminas\\Mvc\\Application or its registered ServiceManager instance. For this, you may utilize the MVC bootstrap event. The bootstrap event is triggered after the loadModule.post event, once $application-&gt;bootstrap() is called. Sample Usage of the MVC \"bootstrap\" Event use Laminas\\EventManager\\EventInterface as Event; class Module { public function onBootstrap(Event $e) { // This method is called once the MVC bootstrapping is complete $application = $e-&gt;getApplication(); $services = $application-&gt;getServiceManager(); } } Use onBootstrap() sparingly The onBootstrap() method is called for every module implementing this feature, on every page request, and should only be used for performing lightweight tasks such as registering event listeners.","title":"The Module Class"},{"location":"module-class/#the-module-class","text":"By default, the module system expects each module name to be capable of resolving to an object instance. The default module resolver, Laminas\\ModuleManager\\Listener\\ModuleResolverListener , instantiates an instance of {moduleName}\\Module for each enabled module.","title":"The Module Class"},{"location":"module-class/#a-minimal-module","text":"As an example, provided the module name \"MyModule\", Laminas\\ModuleManager\\Listener\\ModuleResolverListener will expect the class MyModule\\Module to be available. It relies on a registered autoloader (typically Laminas\\Loader\\ModuleAutoloader ) to find and include the MyModule\\Module class if it isn't already available.","title":"A Minimal Module"},{"location":"module-class/#a-typical-module-class","text":"The following example shows a more typical usage of the Module class: namespace MyModule; class Module { public function getAutoloaderConfig() { return [ 'Laminas\\Loader\\ClassMapAutoloader' =&gt; [ __DIR__ . '/autoload_classmap.php', ], 'Laminas\\Loader\\StandardAutoloader' =&gt; [ 'namespaces' =&gt; [ __NAMESPACE__ =&gt; __DIR__ . '/src/' . __NAMESPACE__, ], ], ]; } public function getConfig() { return include __DIR__ . '/config/module.config.php'; } } For a list of the provided module manager listeners and the interfaces and methods that Module classes may implement in order to interact with the module manager and application, see the module manager listeners and the module mananger events documentation.","title":"A Typical Module Class"},{"location":"module-class/#the-loadmodulespost-event","text":"It is not safe for a module to assume that any other modules have already been loaded at the time init() method is called. If your module needs to perform any actions after all other modules have been loaded, use the module manager's loadModules.post .","title":"The loadModules.post Event"},{"location":"module-class/#the-mvc-bootstrap-event","text":"If you are writing an MVC-oriented module, you may need access to additional parts of the application in your Module class such as the instance of Laminas\\Mvc\\Application or its registered ServiceManager instance. For this, you may utilize the MVC bootstrap event. The bootstrap event is triggered after the loadModule.post event, once $application-&gt;bootstrap() is called.","title":"The MVC \"bootstrap\" Event"},{"location":"module-manager/","text":"The Module Manager The module manager, Laminas\\ModuleManager\\ModuleManager , is responsible for iterating over an array of module names and triggering a sequence of events for each. Instantiation of module classes, initialization tasks, and configuration are all performed by attached event listeners. Module Manager Events The Module Manager events are defined in Laminas\\ModuleManager\\ModuleEvent . loadModules ( ModuleEvent::EVENT_LOAD_MODULES ) This event is primarily used internally to help encapsulate the work of loading modules in event listeners, and allows the loadModules.post event to be more user-friendly. Internal listeners will attach to this event with a negative priority instead of loadModules.post so that users can safely assume things like config merging have been done once loadModules.post is triggered, without having to worry about priorities. loadModule.resolve ( ModuleEvent::EVENT_LOAD_MODULE_RESOLVE ) Triggered for each module that is to be loaded. The listener(s) to this event are responsible for taking a module name and resolving it to an instance of some class. The default module resolver looks for the class {modulename}\\Module , instantiating and returning it if it exists. The name of the module may be retrieved by listeners using the getModuleName() method of the Event object; a listener should then take that name and resolve it to an object instance representing the given module. Multiple listeners can be attached to this event, and the module manager will trigger them in order of their priority until one returns an object. This allows you to attach additional listeners which have alternative methods of resolving modules from a given module name. loadModule ( ModuleEvent::EVENT_LOAD_MODULE ) Once a module resolver listener has resolved the module name to an object, the module manager then triggers this event, passing the newly created object to all listeners. mergeConfig ( ModuleEvent::EVENT_MERGE_CONFIG ) After all modules have been loaded, the mergeConfig event is triggered. By default, Laminas\\ModuleManager\\Listener\\ConfigLister listens on this event at priority 1000, and merges all configuration. You may attach additional listeners to this event in order to manipulate the merged configuration. See the tutorial on manipulating merged configuration for more information. loadModules.post ( ModuleEvent::EVENT_LOAD_MODULES_POST ) This event is triggered by the module manager to allow any listeners to perform work after every module has finished loading. For example, the default configuration listener, Laminas\\ModuleManager\\Listener\\ConfigListener (covered later), attaches to this event to merge additional user-supplied configuration which is meant to override the default supplied configurations of installed modules. Module Manager Listeners By default, Laminas provides several useful module manager listeners. All shipped listeners are in the Laminas\\ModuleManager\\Listener namespace. DefaultListenerAggregate To address the most common use case of the module manager, Laminas provides this default aggregate listener. In most cases, this will be the only listener you will need to attach to use the module manager, as it will take care of properly attaching the requisite listeners (those listed below) for the module system to function properly. AutoloaderListener This listener checks each module to see if it has implemented Laminas\\ModuleManager\\Feature\\AutoloaderProviderInterface or defined the getAutoloaderConfig() method. If so, it calls the getAutoloaderConfig() method on the module class and passes the returned array to Laminas\\Loader\\AutoloaderFactory . ModuleDependencyCheckerListener This listener checks each module to verify if all the modules it depends on were loaded. When a module class implements Laminas\\ModuleManager\\Feature\\DependencyIndicatorInterface or has defined the getModuleDependencies() method, the listener will call getModuleDependencies() . Each of the values returned by the method is checked against the loaded modules list: if one of the values is not in that list, a Laminas\\ModuleManager\\Exception\\MissingDependencyModuleException is thrown. ConfigListener If a module class has a getConfig() method, or implements Laminas\\ModuleManager\\Feature\\ConfigProviderInterface , this listener will call it and merge the returned array (or Traversable object) into the main application configuration. InitTrigger If a module class either implements Laminas\\ModuleManager\\Feature\\InitProviderInterface , or defines an init() method, this listener will call init() and pass the current instance of Laminas\\ModuleManager\\ModuleManager as the sole parameter. Like the OnBootstrapListener , the init() method is called for every module implementing this feature, on every page request and should only be used for performing lightweight tasks such as registering event listeners. LocatorRegistrationListener If a module class implements Laminas\\ModuleManager\\Feature\\LocatorRegisteredInterface , this listener will inject the module class instance into the ServiceManager using the module class name as the service name. This allows you to later retrieve the module class from the ServiceManager . ModuleResolverListener This is the default module resolver. It attaches to the loadModule.resolve event and returns an instance of {moduleName}\\Module . Since 2.8.0, if the module name provided resolves to a fully qualified class name, it returns that verbatim. OnBootstrapListener If a module class implements Laminas\\ModuleManager\\Feature\\BootstrapListenerInterface , or defines an onBootstrap() method, this listener will register the onBootstrap() method with the Laminas\\Mvc\\Application bootstrap event. This method will then be triggered during the bootstrap event (and passed an MvcEvent instance). Like the InitTrigger , the onBootstrap() method is called for every module implementing this feature, on every page request, and should only be used for performing lightweight tasks such as registering event listeners. ServiceListener If a module class implements Laminas\\ModuleManager\\Feature\\ServiceProviderInterface , or defines an getServiceConfig() method, this listener will call that method and aggregate the return values for use in configuring the ServiceManager . The getServiceConfig() method may return either an array of configuration compatible with Laminas\\ServiceManager\\Config , an instance of that class, or the string name of a class that extends it. Values are merged and aggregated on completion, and then merged with any configuration from the ConfigListener falling under the service_manager key. For more information, see the ServiceManager documentation. Unlike the other listeners, this listener is not managed by the DefaultListenerAggregate ; instead, it is created and instantiated within the Laminas\\Mvc\\Service\\ModuleManagerFactory , where it is injected with the current ServiceManager instance before being registered with the ModuleManager events. Additionally, this listener manages a variety of plugin managers, including view helpers , controllers , and controller plugins . In each case, you may either specify configuration to define plugins, or provide configuration via a Module class. Configuration follows the same format as for the ServiceManager . The following table outlines the plugin managers that may be configured this way (including the ServiceManager ), the configuration key to use, the ModuleManager feature interface to optionally implement (all interfaces specified live in the Laminas\\ModuleManager\\Feature namespace) , and the module method to optionally define to provide configuration. Plugin Manager Config Key Interface Module Method Laminas\\Mvc\\Controller\\ControllerManager controllers ControllerProviderInterface getControllerConfig Laminas\\Mvc\\Controller\\PluginManager controller_plugins ControllerPluginProviderInterface getControllerPluginConfig Laminas\\Filter\\FilterPluginManager filters FilterProviderInterface getFilterConfig Laminas\\Form\\FormElementManager form_elements FormElementProviderInterface getFormElementConfig Laminas\\Stdlib\\Hydrator\\HydratorPluginManager hydrators HydratorProviderInterface getHydratorConfig Laminas\\InputFilter\\InputFilterPluginManager input_filters InputFilterProviderInterface getInputFilterConfig Laminas\\Mvc\\Router\\RoutePluginManager route_manager RouteProviderInterface getRouteConfig Laminas\\Serializer\\AdapterPluginManager serializers SerializerProviderInterface getSerializerConfig Laminas\\ServiceManager\\ServiceManager service_manager ServiceProviderInterface getServiceConfig Laminas\\Validator\\ValidatorPluginManager validators ValidatorProviderInterface getValidatorConfig Laminas\\View\\HelperPluginManager view_helpers ViewHelperProviderInterface getViewHelperConfig Laminas\\Log\\ProcessorPluginManager log_processors LogProcessorProviderInterface getLogProcessorConfig Laminas\\Log\\WriterPluginManager log_writers LogWriterProviderInterface getLogWriterConfig Configuration follows the examples in the ServiceManager configuration section . As a brief recap, the following configuration keys and values are allowed: Config Key Allowed values services service name/instance pairs (these should likely be defined only in Module classes invokables service name/class name pairs of classes that may be invoked without constructor arguments (deprecated with laminas-servicemanager v3; use the InvokableFactory instead) factories service names pointing to factories. Factories may be any PHP callable, or a string class name of a class implementing Laminas\\ServiceManager\\FactoryInterface , or of a class implementing the __invoke method (if a callable is used, it should be defined only in Module classes) abstract_factories array of either concrete instances of Laminas\\ServiceManager\\AbstractFactoryInterface , or string class names of classes implementing that interface (if an instance is used, it should be defined only in Module classes) initializers array of PHP callables or string class names of classes implementing Laminas\\ServiceManager\\InitializerInterface (if a callable is used, it should be defined only in Module classes) When working with plugin managers, you will be passed the plugin manager instance to factories, abstract factories, and initializers. If you need access to the application services, you can use the getServiceLocator() method, as in the following example: public function getViewHelperConfig() { return ['factories' =&gt; [ 'foo' =&gt; function ($helpers) { $container = $helpers-&gt;getServiceLocator(); $someService = $container-&gt;get('SomeService'); $helper = new Helper\\Foo($someService); return $helper; }, ]]; } This is a powerful technique, as it allows your various plugins to remain agnostic with regards to where and how dependencies are injected, and thus allows you to use Inversion of Control principals even with plugins. Factories with laminas-servicemanager v3 Starting in the v3 releases of laminas-servicemanager, factories invoked by plugin managers now receive the parent container, and not the plugin manager itself. You can write your factories under v2, and prepare them for v3, by testing the incoming argument to see if it is a plugin manager: use Laminas\\ServiceManager\\AbstractPluginManager; function ($container) { $container = $container instanceof AbstractPluginManager ? $container-&gt;getServiceLocator() : $container; // create instance with dependencies pulled from app container... }","title":"The Module Manager"},{"location":"module-manager/#the-module-manager","text":"The module manager, Laminas\\ModuleManager\\ModuleManager , is responsible for iterating over an array of module names and triggering a sequence of events for each. Instantiation of module classes, initialization tasks, and configuration are all performed by attached event listeners.","title":"The Module Manager"},{"location":"module-manager/#module-manager-events","text":"The Module Manager events are defined in Laminas\\ModuleManager\\ModuleEvent .","title":"Module Manager Events"},{"location":"module-manager/#module-manager-listeners","text":"By default, Laminas provides several useful module manager listeners. All shipped listeners are in the Laminas\\ModuleManager\\Listener namespace.","title":"Module Manager Listeners"}]}